
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>How to use guppy/heapy for tracking down memory usage &#8212; pkgcore trunk documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxdoc.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Plugins system" href="plugins.html" />
    <link rel="prev" title="resolver" href="harring-notes.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="plugins.html" title="Plugins system"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="harring-notes.html" title="resolver"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pkgcore trunk documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../dev-notes.html" accesskey="U">Developer Notes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to use guppy/heapy for tracking down memory usage</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-use-guppy-heapy-for-tracking-down-memory-usage">
<h1>How to use guppy/heapy for tracking down memory usage<a class="headerlink" href="#how-to-use-guppy-heapy-for-tracking-down-memory-usage" title="Permalink to this heading">¶</a></h1>
<p>This is a work in progress. It will grow a bit and it may not be
entirely accurate everywhere.</p>
<section id="tutorial-of-sorts">
<h2>Tutorial of sorts<a class="headerlink" href="#tutorial-of-sorts" title="Permalink to this heading">¶</a></h2>
<p>All this was done on a checkout of
<a class="reference external" href="mailto:marienz&#37;&#52;&#48;gentoo&#46;org-20060908111256-540d8fb3db5b337e">marienz<span>&#64;</span>gentoo<span>&#46;</span>org-20060908111256-540d8fb3db5b337e</a>, you should be able
to check that out and follow along using something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bzr</span> <span class="n">revert</span> <span class="o">-</span><span class="n">rrevid</span><span class="p">:</span><span class="n">marienz</span><span class="nd">@gentoo</span><span class="o">.</span><span class="n">org</span><span class="o">-</span><span class="mi">20060908111256</span><span class="o">-</span><span class="mi">540</span><span class="n">d8fb3db5b337e</span>
</pre></div>
</div>
<p>in a pkgcore branch.</p>
<p>Heapy is powerful but has a learning curve. Problems are the
documentation (<a class="reference external" href="http://guppy-pe.sourceforge.net/heapy_Use.html">http://guppy-pe.sourceforge.net/heapy_Use.html</a> among
others) is a bit unusual and there are various dynamic importing and
other tricks in use that mean things like dir() are less helpful than
they are on more &quot;normal&quot; python objects. This document's main purpose
is to show you how to ask heapy various kinds of questions. It may or
may not show a few cases where pkgcore uses more memory than it should
too.</p>
<p>First, get an x86. Heapy currently does not like 64 bit archs much.</p>
<p>Emerge it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">emerge</span> <span class="n">guppy</span>
</pre></div>
</div>
<p>Fire up an interactive python prompt, set stuff up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">guppy</span> <span class="kn">import</span> <span class="n">hpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pkgcore.config</span> <span class="kn">import</span> <span class="n">load_config</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">load_config</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span> <span class="o">=</span> <span class="n">hpy</span><span class="p">()</span>
</pre></div>
</div>
<p>Just to show how annoying heapy's internal tricks are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span>
<span class="go">[&#39;__doc__&#39;, &#39;__getattr__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__setattr__&#39;, &#39;_hiding_tag_&#39;, &#39;_import&#39;, &#39;_name&#39;, &#39;_owner&#39;, &#39;_share&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span>
<span class="go">Help on class _GLUECLAMP_ in module guppy.etc.Glue:</span>

<span class="go">_GLUECLAMP_ = &lt;guppy.heapy.Use interface at 0x-484b8554&gt;</span>
</pre></div>
</div>
<p>This object is your &quot;starting point&quot;, but as you can see the
underlying machinery is not giving away any useful usage instructions.</p>
<p>Do everything that allocates some memory but is not the problem you
are tracking down now. Then do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span><span class="o">.</span><span class="n">setrelheap</span><span class="p">()</span>
</pre></div>
</div>
<p>Everything allocated before this call will not be in the data sets you
get later.</p>
<p>Now do your memory-intensive thing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">repo</span><span class="p">[</span><span class="s2">&quot;gentoo&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Keep an eye on system memory consumption. You want to use up a lot but
not all of your system ram for nicer statistics. The python process
was eating about 109M res in top when the above stuff finished, which
is pretty good (for my 512mb ram box).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">heap</span><span class="p">()</span>
</pre></div>
</div>
<p>The fun one. This object is basically a snapshot of what's reachable
in ram (minus the stuff excluded through setrelheap earlier) which you
can do various fun tricks with. Its str() is a summary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span>
<span class="go">Partition of a set of 1449133 objects. Total size = 102766644 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span>
<span class="go">     0 985931  68 46300932  45  46300932  45 str</span>
<span class="go">     1  24681   2 22311624  22  68612556  67 dict of pkgcore.ebuild.ebuild_src.package</span>
<span class="go">     2  49391   3 21311864  21  89924420  88 dict (no owner)</span>
<span class="go">     3 115974   8  3776948   4  93701368  91 tuple</span>
<span class="go">     4 152181  11  3043616   3  96744984  94 long</span>
<span class="go">     5  36009   2  1584396   2  98329380  96 weakref.KeyedRef</span>
<span class="go">     6  11328   1  1540608   1  99869988  97 dict of pkgcore.ebuild.ebuild_src.ThrowAwayNameSpace</span>
<span class="go">     7  24702   2   889272   1 100759260  98 types.MethodType</span>
<span class="go">     8  11424   1   851840   1 101611100  99 list</span>
<span class="go">     9  24681   2   691068   1 102302168 100 pkgcore.ebuild.ebuild_src.package</span>
<span class="go">&lt;54 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span>
</pre></div>
</div>
<p>(You might want to keep an eye on ram usage: heapy made the process
grow another dozen mb here. It gets painfully slow if it starts
swapping, so if that happens reduce your data set).</p>
<p>Notice the &quot;Total size&quot; in the top right: about 100M. That's what we
need to compare later numbers with.</p>
<p>So here we can see that (surprise!) we have a ton of strings in
memory. We also have various kinds of dicts. Dicts are treated a bit
specially: the &quot;dict of pkgcore.ebuild.ebuild_src.package&quot; simply
means &quot;all the dicts that are __dict__ attributes of instances of that
class&quot;. &quot;dict (no owner)&quot; are all the dicts that are not used as
__dict__ attribute.</p>
<p>You probably guessed what you can use &quot;index&quot; for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Partition of a set of 985931 objects. Total size = 46300932 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span>
<span class="go">     0 985931 100 46300932 100  46300932 100 str</span>
</pre></div>
</div>
<p>Ok, that looks pretty useless, but it really is not. The &quot;sets&quot; heapy
gives you (like &quot;h&quot; and &quot;h[0]&quot;) are a bunch of objects, grouped
together by an &quot;equivalence relation&quot;. The default one (with the crazy
name &quot;Clodo&quot; for &quot;Class or dict owner&quot;) groups together all objects of
the same class and dicts with the same owner. We can also partition
the sets by a different equivalence relation. Let's do a silly example
first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">bytype</span>
<span class="go">Partition of a set of 1449133 objects. Total size = 102766644 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Type</span>
<span class="go">     0 985931  68 46300932  45  46300932  45 str</span>
<span class="go">     1  85556   6 45226592  44  91527524  89 dict</span>
<span class="go">     2 115974   8  3776948   4  95304472  93 tuple</span>
<span class="go">     3 152181  11  3043616   3  98348088  96 long</span>
<span class="go">     4  36009   2  1584396   2  99932484  97 weakref.KeyedRef</span>
<span class="go">     5  24702   2   889272   1 100821756  98 types.MethodType</span>
<span class="go">     6  11424   1   851840   1 101673596  99 list</span>
<span class="go">     7  24681   2   691068   1 102364664 100 pkgcore.ebuild.ebuild_src.package</span>
<span class="go">     8  11328   1   317184   0 102681848 100 pkgcore.ebuild.ebuild_src.ThrowAwayNameSpace</span>
<span class="go">     9    408   0    26112   0 102707960 100 types.CodeType</span>
<span class="go">&lt;32 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span>
</pre></div>
</div>
<p>As you can see this is the same thing as the default view, but with
all the dicts lumped together. A more useful one is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">byrcs</span>
<span class="go">Partition of a set of 1449133 objects. Total size = 102766644 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)</span>
<span class="go">     0 870779  60 43608088  42  43608088  42 dict (no owner)</span>
<span class="go">     1  24681   2 22311624  22  65919712  64 pkgcore.ebuild.ebuild_src.package</span>
<span class="go">     2 221936  15 20575932  20  86495644  84 dict of pkgcore.ebuild.ebuild_src.package</span>
<span class="go">     3 242236  17  8588560   8  95084204  93 tuple</span>
<span class="go">     4      6   0  1966736   2  97050940  94 dict of weakref.WeakValueDictionary</span>
<span class="go">     5  36009   2  1773024   2  98823964  96 dict (no owner), dict of</span>
<span class="go">                                             pkgcore.ebuild.ebuild_src.package, weakref.KeyedRef</span>
<span class="go">     6  11328   1  1540608   1 100364572  98 pkgcore.ebuild.ebuild_src.ThrowAwayNameSpace</span>
<span class="go">     7  26483   2   800432   1 101165004  98 list</span>
<span class="go">     8  11328   1   724992   1 101889996  99 dict of pkgcore.ebuild.ebuild_src.ThrowAwayNameSpace</span>
<span class="go">     9      3   0   393444   0 102283440 100 dict of pkgcore.repository.prototype.IterValLazyDict</span>
<span class="go">&lt;132 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span>
</pre></div>
</div>
<p>What this does is:</p>
<ul class="simple">
<li><p>for every object, find all its referrers</p></li>
<li><p>Classify those referrers using the &quot;Clodo&quot; relation you saw earlier</p></li>
<li><p>Create a set of those classifiers of referrers. That means a set of
things like &quot;tuple, dict of someclass&quot;, <em>not</em> of actual referring objects.</p></li>
<li><p>Group together all the objects with the same set of classifiers of referrers.</p></li>
</ul>
<p>So now we know that we have a lot of objects referenced <em>only</em> by one
or more dicts (still not very useful) and also a lot of them
referenced by one &quot;normal&quot; dict, referenced by the dict of (meaning
&quot;an attribute of&quot;) ebuild_src.package, and referenced by a WeakRef.
Hmm, I wonder what those are. But let's store this view of the data
first, since it took a while to generate (&quot;_&quot; is a feature of the
python interpreter, it's always the last result):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span> <span class="o">=</span> <span class="n">_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">Partition of a set of 36009 objects. Total size = 1773024 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)</span>
<span class="go">     0  36009 100  1773024 100   1773024 100 dict (no owner), dict of</span>
<span class="go">                                             pkgcore.ebuild.ebuild_src.package, weakref.KeyedRef</span>
</pre></div>
</div>
<p>Erm, yes, we knew that already. If you look in the top right of the
table you can see it is still grouping the items by the kind of their
referrer, which is not very useful here. To get more information we
can change what they are grouped by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">byclodo</span>
<span class="go">Partition of a set of 36009 objects. Total size = 1773024 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span>
<span class="go">     0  36009 100  1773024 100   1773024 100 str</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">bysize</span>
<span class="go">Partition of a set of 36009 objects. Total size = 1773024 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Individual Size</span>
<span class="go">     0  10190  28   489120  28    489120  28        48</span>
<span class="go">     1   7584  21   394368  22    883488  50        52</span>
<span class="go">     2   7335  20   322740  18   1206228  68        44</span>
<span class="go">     3   3947  11   221032  12   1427260  80        56</span>
<span class="go">     4   3364   9   134560   8   1561820  88        40</span>
<span class="go">     5   1903   5   114180   6   1676000  95        60</span>
<span class="go">     6    877   2    56128   3   1732128  98        64</span>
<span class="go">     7    285   1    19380   1   1751508  99        68</span>
<span class="go">     8    451   1    16236   1   1767744 100        36</span>
<span class="go">     9     57   0     4104   0   1771848 100        72</span>
</pre></div>
</div>
<p>This took the set of objects with that odd set of referrers and
redisplayed them grouped by &quot;clodo&quot;. So now we know they're all
strings. Most of them are pretty small too. To get some idea of what
we're dealing with we can pull some random examples out:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">byid</span>
<span class="go">Set of 36009 &lt;str&gt; objects. Total size = 1773024 bytes.</span>
<span class="go"> Index     Size   %   Cumulative  %   Representation (limited)</span>
<span class="go">     0       80   0.0        80   0.0 &#39;media-plugin...re20051219-r1&#39;</span>
<span class="go">     1       76   0.0       156   0.0 &#39;app-emulatio...4.20041102-r1&#39;</span>
<span class="go">     2       76   0.0       232   0.0 &#39;dev-php5/ezc...hemaTiein-1.0&#39;</span>
<span class="go">     3       76   0.0       308   0.0 &#39;games-misc/f...wski-20030120&#39;</span>
<span class="go">     4       76   0.0       384   0.0 &#39;mail-client/...pt-viewer-0.8&#39;</span>
<span class="go">     5       76   0.0       460   0.0 &#39;media-fonts/...-100dpi-1.0.0&#39;</span>
<span class="go">     6       76   0.0       536   0.0 &#39;media-plugin...gdemux-0.10.4&#39;</span>
<span class="go">     7       76   0.0       612   0.0 &#39;media-plugin...3_pre20051219&#39;</span>
<span class="go">     8       76   0.0       688   0.0 &#39;media-plugin...3_pre20051219&#39;</span>
<span class="go">     9       76   0.0       764   0.0 &#39;media-plugin...3_pre20060502&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">byid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">theone</span>
<span class="go">&#39;media-plugins/vdr-streamdev-server-0.3.3_pre20051219-r1&#39;</span>
</pre></div>
</div>
<p>A pattern emerges! (sets with one item have a &quot;theone&quot; attribute with
the actual item, all sets have a &quot;nodes&quot; attribute that returns an
iterator yielding the items).</p>
<p>We could have used another heapy trick to get a better idea of what
kind of string this was:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">byvia</span>
<span class="go">Partition of a set of 36009 objects. Total size = 1773024 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referred Via:</span>
<span class="go">     0      1   0       80   0        80   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[23147]&#39;</span>
<span class="go">     1      1   0       76   0       156   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[12285]&#39;</span>
<span class="go">     2      1   0       76   0       232   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[12286]&#39;</span>
<span class="go">     3      1   0       76   0       308   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[16327]&#39;</span>
<span class="go">     4      1   0       76   0       384   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[17754]&#39;</span>
<span class="go">     5      1   0       76   0       460   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[19079]&#39;</span>
<span class="go">     6      1   0       76   0       536   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[21704]&#39;</span>
<span class="go">     7      1   0       76   0       612   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[23473]&#39;</span>
<span class="go">     8      1   0       76   0       688   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[24239]&#39;</span>
<span class="go">     9      1   0       76   0       764   0 &quot;[&#39;cpvstr&#39;]&quot;, &#39;.key&#39;, &#39;.keys()[3070]&#39;</span>
<span class="go">&lt;35999 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span>
</pre></div>
</div>
<p>Ouch, 36009 total rows for 36009 objects. What this did is similar to
what &quot;byrcs&quot; did: for every object in the set it determined how they
can be reached through their referrers, then groups objects that can
be reached in the same ways together. Unfortunately it is grouping
everything reachable as a dictionary key differently, so this is not
very useful.</p>
<p>XXX WTF XXX</p>
<p>It is not likely this accomplishes anything, but let's assume we want
to know if there are any objects in this set <em>not</em> reachable as the
&quot;key&quot; attribute. Heapy can tell us (although this is <em>very</em> slow...
there might be a better way but I do not know it yet):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonkeys</span> <span class="o">=</span> <span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">.</span><span class="n">Via</span><span class="p">(</span><span class="s1">&#39;.key&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">alt</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonkeys</span><span class="o">.</span><span class="n">byrcs</span>
<span class="go">hp.Nothing</span>
</pre></div>
</div>
<p>(remember &quot;hp&quot; was our main entrance into heapy, the object that gave
us the set of all objects we're interested in earlier).</p>
<p>What does this do? &quot;hp.Via('.key')&quot; creates a &quot;symbolic set&quot; of &quot;all
objects reachable <em>only</em> as the 'key' attribute of something&quot; (it's a
&quot;symbolic set&quot; because there are no actual objects in it). The &quot;alt&quot;
method gives us a new symbolic set of everything reachable via &quot;less
than&quot; this way. We then intersect this with our set and discover there
is nothing left.</p>
<p>A similar construct that does not do what we want is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonkeys</span> <span class="o">=</span> <span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">hp</span><span class="o">.</span><span class="n">Via</span><span class="p">(</span><span class="s1">&#39;.key&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The &quot;~&quot; operator inverts the symbolic set, giving a set matching
everything not reachable <em>exactly</em> as a &quot;key&quot; attribute. The key word
here is &quot;exactly&quot;: since everything in our set was also reachable in
two other ways this intersection matches everything.</p>
<p>Ok, let's get back to the stuff actually eating memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">byrcs</span>
<span class="go">Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)</span>
<span class="go">    0 670791  68 31716096  68  31716096  68 dict (no owner)</span>
<span class="go">    1 139232  14  6525856  14  38241952  83 tuple</span>
<span class="go">    2 136558  14  6042408  13  44284360  96 dict of pkgcore.ebuild.ebuild_src.package</span>
<span class="go">    3  36009   4  1773024   4  46057384  99 dict (no owner), dict of</span>
<span class="go">                                            pkgcore.ebuild.ebuild_src.package, weakref.KeyedRef</span>
<span class="go">    4   1762   0   107772   0  46165156 100 list</span>
<span class="go">    5    824   0    69476   0  46234632 100 types.CodeType</span>
<span class="go">    6    140   0    31312   0  46265944 100 function, tuple</span>
<span class="go">    7    194   0    11504   0  46277448 100 dict of module</span>
<span class="go">    8     30   0     6284   0  46283732 100 dict of type</span>
<span class="go">    9     55   0     1972   0  46285704 100 dict of module, tuple</span>
</pre></div>
</div>
<p>Remember h[0] gave us all str objects, so this is all string objects
grouped by the kind(s) of their referrers. Also notice index 3 here is
the same set of stuff we saw earlier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">byrcs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^</span> <span class="n">byrcs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">hp.Nothing</span>
</pre></div>
</div>
<p>Most operators do what you would expect, &amp; intersects for example.</p>
<p>&quot;We have a lot of strings in dicts&quot; is not that useful either, let's
see if we can narrow that down a little:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">byrcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">referrers</span><span class="o">.</span><span class="n">byrcs</span>
<span class="go">Partition of a set of 44124 objects. Total size = 18636768 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)</span>
<span class="go">     0  24681  56 12834120  69  12834120  69 dict of pkgcore.ebuild.ebuild_src.package</span>
<span class="go">     1  19426  44  5371024  29  18205144  98 dict (no owner)</span>
<span class="go">     2      1   0   393352   2  18598496 100 dict of pkgcore.repository.prototype.IterValLazyDict</span>
<span class="go">     3      1   0     6280   0  18604776 100 __builtin__.set</span>
<span class="go">     4      1   0     6280   0  18611056 100 dict of module, guppy.heapy.heapyc.RootStateType</span>
<span class="go">     5      1   0     6280   0  18617336 100 dict of pkgcore.ebuild.eclass_cache.cache</span>
<span class="go">     6      1   0     6280   0  18623616 100 dict of</span>
<span class="go">                                             pkgcore.repository.prototype.PackageIterValLazyDict</span>
<span class="go">     7      4   0     5536   0  18629152 100 type</span>
<span class="go">     8      4   0     3616   0  18632768 100 dict of type</span>
<span class="go">     9      1   0     1672   0  18634440 100 dict of module, dict of os._Environ</span>
</pre></div>
</div>
<p>(Broken down: h[0].byrcs[0] is the set of all str objects referenced
only by dicts, h[0].byrcs[0].referrers is the set of those dicts, and
the final .byrcs displays those dicts grouped by <em>their</em> referrers)</p>
<p>Keep an eye on the size column. We have over 12M worth of just dicts
(not counting the stuff in them) referenced only as attribute of
ebuild_src.package. If we include the stuff kept alive by those dicts
we're talking about a big chunk of the 100MB total here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domisize</span>
<span class="go">61269552</span>
</pre></div>
</div>
<p>60M out of our 100M would be deallocated if we killed those dicts. So
let's ask heapy what dicts that are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">byvia</span>
<span class="go">Partition of a set of 24681 objects. Total size = 12834120 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referred Via:</span>
<span class="go">     0  24681 100 12834120 100  12834120 100 &quot;[&#39;data&#39;]&quot;</span>
</pre></div>
</div>
<p>(it is easy to get confused by the &quot;byrcs&quot; view of our &quot;t&quot;. t[0] is
<em>not</em> a bunch of &quot;dict of ebuild_src.package&quot;. It is a bunch of dicts
with strings in them, namely those that are <em>referred to</em> by the dict
of ebuild_src.package, and not by anything else. So the byvia output
means those dicts with strings in them are all &quot;data&quot; attributes of
ebuild_src.package instances).</p>
<p>(sidenote: earlier we saw byvia say &quot;.key&quot;, now it says &quot;['data']&quot;.
It's different because the previous type used __slots__ (so there was
no &quot;dict of&quot; involved) and this type does not (so there is a &quot;dict of&quot;
and our dicts are the &quot;data&quot; key in it).</p>
<p>So what is in the dicts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">referents</span>
<span class="go">Partition of a set of 605577 objects. Total size = 34289392 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)</span>
<span class="go">     0 556215  92 27710068  81  27710068  81 str</span>
<span class="go">     1  24681   4  6085704  18  33795772  99 dict (no owner)</span>
<span class="go">     2  24681   4   493620   1  34289392 100 long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="o">.</span><span class="n">byvia</span>
<span class="go">Partition of a set of 605577 objects. Total size = 34289392 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Referred Via:</span>
<span class="go">     0  24681   4  6085704  18   6085704  18 &quot;[&#39;_eclasses_&#39;]&quot;</span>
<span class="go">     1  21954   4  3742976  11   9828680  29 &quot;[&#39;DEPEND&#39;]&quot;</span>
<span class="go">     2  22511   4  3300052  10  13128732  38 &quot;[&#39;RDEPEND&#39;]&quot;</span>
<span class="go">     3  24202   4  2631304   8  15760036  46 &quot;[&#39;SRC_URI&#39;]&quot;</span>
<span class="go">     4  24681   4  1831668   5  17591704  51 &quot;[&#39;DESCRIPTION&#39;]&quot;</span>
<span class="go">     5  24674   4  1476680   4  19068384  56 &quot;[&#39;HOMEPAGE&#39;]&quot;</span>
<span class="go">     6  24681   4  1297680   4  20366064  59 &quot;[&#39;KEYWORDS&#39;]&quot;</span>
<span class="go">     7  24681   4   888516   3  21254580  62 &#39;.keys()[3]&#39;</span>
<span class="go">     8  24681   4   888516   3  22143096  65 &#39;.keys()[9]&#39;</span>
<span class="go">     9  24681   4   810108   2  22953204  67 &quot;[&#39;LICENSE&#39;]&quot;</span>
<span class="go">&lt;32 more rows. Type e.g. &#39;_.more&#39; to view.&gt;</span>
</pre></div>
</div>
<p>Strings, nested dicts and longs, and most size eaten up by the
&quot;_eclasses_&quot; values. There is also a significant amount eaten up by
keys values, which is a bit odd, so let's investigate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">refs</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">referents</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">=</span><span class="nb">iter</span><span class="p">(</span><span class="n">refs</span><span class="o">.</span><span class="n">byvia</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;DESCRIPTION&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;DESCRIPTION&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;DESCRIPTION&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;DESCRIPTION&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;DESCRIPTION&#39;</span>
</pre></div>
</div>
<p>Eep!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">refs</span><span class="o">.</span><span class="n">byvia</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">bysize</span>
<span class="go">Partition of a set of 24681 objects. Total size = 888516 bytes.</span>
<span class="go"> Index  Count   %     Size   % Cumulative  % Individual Size</span>
<span class="go">     0  24681 100   888516 100    888516 100        36</span>
</pre></div>
</div>
<p>It looks like we have 24681 identical strings here, using up about 1M
of memory. The other odd entry is the '_eclasses_' string apparently.</p>
</section>
<section id="extra-stuff-for-c-extension-developers">
<h2>Extra stuff for c extension developers<a class="headerlink" href="#extra-stuff-for-c-extension-developers" title="Permalink to this heading">¶</a></h2>
<p>To provide accurate statistics if your code uses extension types you
must provide heapy with a way to get the following data for your
custom types:</p>
<ul class="simple">
<li><p>How large is a certain instance?</p></li>
<li><p>What objects does an instance contain?</p></li>
<li><p>How does the instance refer to a contained object?</p></li>
</ul>
<p>You provide these through a NyHeapDef struct, defined in heapdef.h in
the guppy source. This header is not installed, so you should just
copy it into your source tree. It is a good idea to read this header
file side by side with the following descriptions, since it contains
details omitted here. The stdtypes.c file contains implementations for
the basic python types which you can read for inspiration.</p>
<p>The NyHeapDef struct provides heapy with three function pointers:</p>
<section id="sizegetter">
<h3>SizeGetter<a class="headerlink" href="#sizegetter" title="Permalink to this heading">¶</a></h3>
<p>To answer &quot;how large is an instance&quot; you provide a
NyHeapDef_SizeGetter function that is called with a PyObject* and
returns an int: the number of bytes the object occupies. If you do not
provide this function heapy uses a default that looks at the
tp_basicsize and tp_itemsize fields of the type. This means that if
you do not allocate any extra memory for non-python objects (e.g. for
c strings) you do not need to provide this function.</p>
</section>
<section id="traverser">
<h3>Traverser<a class="headerlink" href="#traverser" title="Permalink to this heading">¶</a></h3>
<p>To answer &quot;What objects does an instance contain&quot; you provide a
traversal function (NyHeapDef_Traverser). This is called with a
pointer to a &quot;visit procedure&quot;, an instance of your extension type and
some other stuff. You should then call the visit procedure for every
python object contained in your object.</p>
<p>This might sound familiar: to support the python garbage collector you
provide a very similar function (tp_traverse). Actually heapy will use
tp_traverse if you do not provide a heapy-specific traverse function.
Doing this makes sense if you do not support the garbage collector for
some reason, or if you contain objects that are irrelevant to the
garbage collector.</p>
<p>An example would be a type that contains a single python string
object (that no other code can get a reference to). If this object
does not have references to other python objects it cannot be involved
in cycles so supporting gc would be useless. However you do still want
heapy to know about the memory occupied by the contained string. You
could do that by adding that size in your NyHeapDef_SizeGetter
function but it is probably easier to tell heapy about the string
through the traversal function (so you do not have to calculate the
memory occupied by the string).</p>
<p>If the above type would also have a reference to some arbitrary
(non-private) python object it should support gc, but it does not need
to tell gc about the contained string. So you would have two traversal
functions, one for heapy that visits the string and one for gc that
does not.</p>
</section>
<section id="relationgetter">
<h3>RelationGetter<a class="headerlink" href="#relationgetter" title="Permalink to this heading">¶</a></h3>
<p>The last function heapy wants tells it in what way your instance
refers to some contained object. It is used to provide the &quot;byvia&quot;
view. This calls a visit function once for each way your instance
refers to a target object, telling it what kind of reference it is.</p>
</section>
<section id="providing-the-heapdef-struct-to-heapy">
<h3>Providing the heapdef struct to heapy<a class="headerlink" href="#providing-the-heapdef-struct-to-heapy" title="Permalink to this heading">¶</a></h3>
<p>Once you have the needed function pointers in a struct you need to
pass this to heapy somehow. This is done through a standard cpython
mechanism called &quot;cobjects&quot;. From python these look like rather stupid
objects you cannot do anything with, but from c you can pull out a
void* that was put in when the object was constructed. You can wrap an
arbitrary pointer in a CObject, make it available as attribute of your
module, then import it from some other module, pull the void* back
out and cast it to the original type.</p>
<p>heapy looks for a _NyHeapDefs_ attribute on all loaded modules. If
this attribute exists and is a CObject the pointer in it is used as a
pointer to an array of NyHeapDef struct (terminated with a struct with
only nulls). Example code doing this is in sets.c in the guppy source.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">How to use guppy/heapy for tracking down memory usage</a><ul>
<li><a class="reference internal" href="#tutorial-of-sorts">Tutorial of sorts</a></li>
<li><a class="reference internal" href="#extra-stuff-for-c-extension-developers">Extra stuff for c extension developers</a><ul>
<li><a class="reference internal" href="#sizegetter">SizeGetter</a></li>
<li><a class="reference internal" href="#traverser">Traverser</a></li>
<li><a class="reference internal" href="#relationgetter">RelationGetter</a></li>
<li><a class="reference internal" href="#providing-the-heapdef-struct-to-heapy">Providing the heapdef struct to heapy</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="harring-notes.html"
                          title="previous chapter">resolver</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="plugins.html"
                          title="next chapter">Plugins system</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="plugins.html" title="Plugins system"
             >next</a> |</li>
        <li class="right" >
          <a href="harring-notes.html" title="resolver"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pkgcore trunk documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../dev-notes.html" >Developer Notes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to use guppy/heapy for tracking down memory usage</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019, pkgcore contributors.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
  </body>
</html>